## 面试题

###  彻底搞懂上下文this

```javascript

var obj = {
	a:3,
	b:4,
	fn(){
		alert(this.a);
	}
}
var a = 8;
var f = obj.fn;
f(); 
//this 是啥
//this的具体值取决于函数如何被调用
//
```

> 彻底搞懂上下文this
>
> 规则1:函数直接用圆括号运行，上下文是window对象。
>
> fn();
>
> 规则2:对象打点调用函数，上下文是这个对象。
>
> 规则3:数组中枚举出函数，然后运行，（类数组对象）
>
> 规则4:定时器调用函数，上下文是windows
>
> 规则5:被当做了事件处理函数，上下文是触发事件的dom元素。
>
> 规则6:用new调用函数。上下文是函数体内部秘密创建的空对象。
>
> 用new调用函数经历4步走
>
> 1、秘密创建空对象
>
> 2、将this绑定到这个空对象中。
>
> 3、执行语句
>
> 4、返回这个对象。
>
> 规则7: call、apply、bind

> call、apply、bind 代码实现：



```javascript
var value = 1;

var foo = {
  value: 2,
  bar: function () {
    return this.value;
  }
}

//示例1
console.log(foo.bar()); // 2
//示例2
console.log((foo.bar)()); // 2
//示例3
console.log((foo.bar = foo.bar)()); // 1
//示例4
console.log((false || foo.bar)()); // 1
//示例5
console.log((foo.bar, foo.bar)()); // 1
```



#### new的模拟实现

```javascript
// 第二版的代码
function objectFactory() {

    var obj = new Object(),

    Constructor = [].shift.call(arguments);

    obj.__proto__ = Constructor.prototype;

    var ret = Constructor.apply(obj, arguments);

    return typeof ret === 'object' ? ret : obj;

};
```



#### bind的模拟实现

```javascript
Function.prototype.bind2 = function (context) {

    if (typeof this !== "function") {
      throw new Error("Function.prototype.bind - what is trying to be bound is not callable");
    }

    var self = this;
    var args = Array.prototype.slice.call(arguments, 1);

    var fNOP = function () {};

    var fBound = function () {
        var bindArgs = Array.prototype.slice.call(arguments);
        return self.apply(this instanceof fNOP ? this : context, args.concat(bindArgs));
    }

    fNOP.prototype = this.prototype;
    fBound.prototype = new fNOP();
    return fBound;
}
```



####  apply的模拟实现

```javascript
Function.prototype.apply = function (context, arr) {
    var context = Object(context) || window;
    context.fn = this;

    var result;
    if (!arr) {
        result = context.fn();
    }
    else {
        var args = [];
        for (var i = 0, len = arr.length; i < len; i++) {
            args.push('arr[' + i + ']');
        }
        result = eval('context.fn(' + args + ')')
    }

    delete context.fn
    return result;
}
```

#### call 的模拟实现

```javascript
// 第三版
Function.prototype.call2 = function (context) {
    var context = context || window;
    context.fn = this;

    var args = [];
    for(var i = 1, len = arguments.length; i < len; i++) {
        args.push('arguments[' + i + ']');
    }

    var result = eval('context.fn(' + args +')');

    delete context.fn
    return result;
}

// 测试一下
var value = 2;

var obj = {
    value: 1
}

function bar(name, age) {
    console.log(this.value);
    return {
        value: this.value,
        name: name,
        age: age
    }
}

bar.call2(null); // 2

console.log(bar.call2(obj, 'kevin', 18));
// 1
// Object {
//    value: 1,
//    name: 'kevin',
//    age: 18
// }

```

```javascript
var obj = {
a:3,
d:4,
fun:function(){
var a = 5;
return function(){
alert(this.a);
}
}
}
var a = 7;
obj.fun()();//规则1
```

>
>
>

```
function fun1(fn){
	arguments[0](3,4);
}
function fun2(){
	alert(this.length)
}
fun1(fun2,5,6,7,8)
```

>//面试题举例：
>
>*function* Foo() {
>
>​    *function* getName() {
>
>​        *console*.log(1)
>
>​    }
>
>​    return this
>
>}
>
>Foo.getName = *function*() {
>
>​    *console*.log(2)
>
>}
>
>*Foo*.prototype.getName = *function*() {
>
>​    *console*.log(3)
>
>}
>
>*var* getName = *function*() {
>
>​    *console*.log(4)
>
>}
>
>
>
>*function* getName() {
>
>​    *console*.log(5)
>
>}
>
>
>
>getName() //4  函数的声明先提前，不是5
>
>Foo().getName()
>
>new Foo().getName() //new 的运算级别非常高，原型链的查找
>
>new Foo.getName() //普通函数，不是构造函数，
>
>new new Foo().getName()
>
>

```javascript
function getLength() {
    return this.length
}

function foo() {
    this.length = 1
    return (function() {
        var length = 2
        return {
            length: function(a, b, c) {
                return this.arr.length
            },
            arr: [1, 2, 3, 4],
            info: function() {
                return getLength.call(this.length)
            },
        }
    })()
}

var result = foo().info()
console.log(result)
```

> ​    //arguments.callee
>
> ​    //函数的长度length 是形参的个数

```javascript
function fun() {
    var a = 1
    this.a = 2 //window

    function fn() {
        return this.a
    }
    fn.a = 3
    return fn
}
alert(fun()())
```





```javascript
var a = 1
var obj = {
    a: 2,
    getA: function() {
        return this.a
    },
}
var getA = obj.getA
getA()
```



```javascript
//----
var number = 2
var obj = {
    number: 4,
    fn1: (function() {
        this.number *= 2
        number = number * 2
        var number = 3
        return function() {
            this.number *= 2
            number *= 3
            alert(numebr)
        }
    })(),
}

alert(number)
var fn1 = obj.fn1
fn1()
obj.fn1()
alert(window.number)
alert(obj.number)
```



```javascript
var number = 2
var obj = {
    number: 4,
    fn1: (function() {
        this.number *= 2
        number = number * 2
        var number = 3
        return function() {
            this.number *= 2
            number *= 3
            console.log(number)
        }
    })(),
}

console.log(number)//4
var fn1 = obj.fn1
fn1()//9
obj.fn1()//27
console.log(window.number)//8
console.log(obj.number)//8
```



```javascript
var number = 2
var obj = {
    number: 4,
    fn1: (function() {
        //var number = undefined
        this.number *= 2
        number = number * 2
        var number = 3
        console.log(this.number);
        console.log(number);
        return function() {
            this.number *= 2
            console.log(this)
            console.log(this.number)
            number *= 3
            console.log(number)
        }
    })(),
}

console.log(number)//4
var fn1 = obj.fn1
fn1()//9
obj.fn1()//27
console.log(window.number)//8
console.log(obj.number)//8
```





### 数组的相关算法

####   使用set进行去重。

```

const arr = [1,1,2,2,3,3]
const set = new Set(arr);
console.log([...set]);

```





```
//==  ===
function uniq(arr){
 var _result = [];
 for(let i = 0; i< arr.length ; i++){
 	if(!_result.includes(arr[i])){
 	_result.push(arr[i]);
}
}
return _arr
}
console.log(uniq(arr))
```



####  冒泡排序

```javascript
function bubbleSort(arr) {
    for (let i = 0; i < arr.length - 1; i++) {
        for (let j = 0; j < arr.length - 1 - i; j++) {
            if (arr[j] > arr[j + 1]) {
                var temp = arr[j]
                arr[j] = arr[j + 1]
                arr[j + 1] = temp
            }
        }
    }
    return arr
}

var arr = [43, 65, 34, 21, 34, 56, 346, 763, 14]
bubbleSort(arr)
console.log(arr)

```

#### 快速排序

```javascript
// 时间复杂度  nlongn
function quickSort(arr) {
    if (arr.length <= 1) {
        return arr
    }
    const pivot = arr[0]
    var bigger = []
    var smaller = []
    for (let i = 1; i < arr.length; i++) {
        if (arr[i] >= pivot) {
            bigger.push(arr[i])
        } else {
            smaller.push(arr[i])
        }
    }
    return quickSort(smaller).concat(pivot, quickSort(bigger))
}
var arr = [56, 3234, 24, 64, 3, 45, 12, 456, 88, 99, 32]
console.log(quickSort(arr))

```

####  数组扁平化

```javascript
var arr = [0, [1, 2, 3], [4, [1, [2, 3, [9, 0]]]]]
function flattenArray(arr) {
    var _arr = []
    for (let i = 0; i < arr.length; i++) {
        if (!Array.isArray(arr[i])) {
            _arr.push(arr[i])
        } else {
            _arr = _arr.concat(flattenArray(arr[i]))
        }
    }
    return _arr
}

console.log(flattenArray(arr))

```



>数组的识别 Array.isArray
>
>Object.protype.toString.call(o) == 
>
>数组的方法
>
>数组的样本，交集，并集



#### 函数柯里化， curry

```javascript
function curry(fn) {
    return function() {
        ars = arguments
        return function() {
            return fn(...ars, ...arguments)
        }
    }
}

function fun(a, b, c, d) {
    return a + b + c + d
}

fun = curry(fun)

var fn = fun(1,2);
console.log(fn(4,5))
```



> react 的ramda   loadsh



#### 深浅克隆



```javascript
var arr = [1, 2, 3, 4, [66, 77, 88]]
function deepClone(o) {
    if (
        typeof o == 'string' ||
        typeof o == 'number' ||
        typeof o == 'boolean' ||
        typeof o == 'undefined'
    ) {
        return o
    } else if (Array.isArray(o)) {
        var _arr = []
        for (let i = 0; i < o.length; i++) {
            _arr.push(deepClone(o[i]))
        }
        return _arr
    } else if (typeof o == 'object') {
        var _o = {}
        for (var k in o) {
            _o[k] = deepClone(o[k])
        }
        return _o
    }
}

```



#### 闭包

```javascript
//闭包是函数外部的事情，不是自己的事情
var a = 10
function fun() {
    console.log(a)
}
;(function(fn) {
    var a = 20
    fn()
})(fun)

```



#### 偏函数



>  alert(1&&2)  结果是什么



> 正则表达式验证长度为8-16的用户密码（只能出现字母、数字、下划线）



> ![image-20191217182939425](../France/nodejs-projects/summary/src/assets/image-20191217182939425.png)

![image-20191217222550037](../France/nodejs-projects/summary/src/assets/image-20191217222550037.png)



![image-20191217223047774](../France/nodejs-projects/summary/src/assets/image-20191217223047774.png)



#### cookie



![image-20191217224417005](../France/nodejs-projects/summary/src/assets/image-20191217224417005.png)

![image-20191217224437011](../France/nodejs-projects/summary/src/assets/image-20191217224437011.png)



#### session

>  密文的cookie，不是新技术，就是cookie 不是明文传输，而是乱码

#### Token

sha256 md5 是不可逆的算法。可以公开传输。

![image-20191217225552440](../France/nodejs-projects/summary/src/assets/image-20191217225552440.png)



![image-20191217230833833](../France/nodejs-projects/summary/src/assets/image-20191217230833833.png)



localStorage、sessionStorage 



#### 跨域（代理跨域，cors跨域，jsonp）





####  六种继承方式



```javascript
function Parent (name) {
    this.name = name;
    this.colors = ['red', 'blue', 'green'];
}

Parent.prototype.getName = function () {
    console.log(this.name)
}

function Child (name, age) {
    Parent.call(this, name);
    this.age = age;
}

// 关键的三步
var F = function () {};

F.prototype = Parent.prototype;

Child.prototype = new F();


var child1 = new Child('kevin', '18');

console.log(child1);
```



